# OXIDICE

简体中文 | [English](README.md)

这是一个用于桌面角色扮演游戏的快速、可扩展的骰子表达式引擎，使用 Rust 编写并可以编译为 WASM 执行。

## 概述

Oxidice 是一款为桌面角色扮演游戏系统设计的骰子表达式解析器和执行引擎。支持大多数常见的骰子语法，也加入了部分自定义语法，并为前端应用提供了 Rust API 和 WebAssembly 接口。可以在网页应用中直接使用，也可以配合[@3d-dice/dice-box](https://github.com/3d-dice/dice-box)相应的动画

## 项目动机

开始此项目出于 2 方面的原因：

1. 对目前大部分现存的骰子表达式解析器和执行引擎的功能不满，主要体现在如下方面：

   - 对嵌套投掷（如`(1d6)d6`）的支持缺失或不完善，如 Roll20 所使用的引擎并不支持嵌套投掷，fvtt 使用的引擎虽然支持嵌套投掷，但是投掷动画和结果展示等配套功能支持不完善；

   - 缺少对列表的原生支持，大部分引擎并不支持列表，fvtt 中列表的行为非常怪异，易用性很差；

   - 修饰符行为的不一致，对于一个骰子后添加多个修饰符的情况，用户难以对最后的结果做出合理预期；

   - 函数支持(如`max`、`min`等)，以 fvtt 为例，其依赖于 javascript 本身的函数，抛开安全问题，其这种使用方式也导致了不能在表达式中的任意位置使用函数；

   - 在投掷前不能知道表达式是否合法，对于不合法的表达式也没有相应提示。

2. 使用现存的骰子表达式解析器和执行引擎的开发体验较差，它们大部分基于 javascript，而且缺少完整的类型提示，导致开发和调试体验很差。

## 特性

- 较为完整的修饰符支持，从功能上支持目前大多数常见的修饰符
- 原生的函数支持，以关键字的形式支持常见函数，不依赖于 javascript
- 原生的列表支持，在此引擎中，列表作为一等公民存在，并有配套函数支持
- 完整的结果记录，几乎所有投掷产生的数据以及中间节点的值都会被记录
- 完整的嵌套支持，几乎可以在任何地方嵌套，并且可以按照顺序播放对应的动画
- 支持常数折叠和有限的表达式合并：如`1 + max(1,2,3)`会在编译阶段被折叠为`4`，`2d6 + 2d6`会被优化为`4d6`。此功能旨在简化表达式，方便用户查看结果
- 支持类型检查，可以在投掷前得知表达式是否合法

## 快速开始

### 在命令行中快速测试功能

```
cargo run --bin oxidice
```

### 在网页应用项目中使用

首先编译为 wasm（取决于你使用 wasm 的方式）：

```
wasm-pack build --target bundler
```

或

```
wasm-pack build --target web
```

后续使用见[示例项目](https://github.com/xuyisen-x/oxidice-example)：

## 详细介绍

### 类型系统

本引擎具有完整的类型系统：

- 列表类型：有一系列简单数值类型组成的列表
- 数值类型：
  - 简单数值类型：一个数字
  - 骰子池：一次或多次投掷产生的投掷结果组成的集合，后续操作可能会从中添加或移出投掷结果，在需要简单数值类型时，会以加和的形式转化为简单数值类型
    > 以`3d20dl + 1`为例，假设`3d20`产生结果`[5, 19, 7]`，这是一个骰子池类型，经过`dl`后（本引擎的修饰符如管道符一样工作），骰池变为`[19, 7]`，与`1`进行加法运算时，因为加法运算需求一个简单数值类型，骰池以加和形式坍缩为`26`并于`1`运算，最后得到结果`27`
  - 成功池：一次或多次投掷产生的投掷结果组成的集合，且每一个投掷结果有一标签（成功 S，失败 F、正常 N），后续操作可能会修改投掷结果的标签，在需要简单数值类型时，成功记为 1，失败记为-1，正常记为 0，加和后转化为简单数值类型
    > 以`4d20cs>=5df>19 + 1`为例，假设`4d20`产生结果`[5, 20, 7, 1]`，这是一个骰子池类型，经过`cs>=5`后，类型被转化为成功池，并且所有大于等于 5 的结果被打上成功的标签，为`[5:S, 20:S, 7:S, 1:N]`，经过`df>19`后，所有大于 19 的结果被重新打上失败的标签为`[5:S, 20:F, 7:S, 1:N]`，与`1`进行加法运算时，因为加法运算需求一个简单数值类型，成功池中有 2 个成功，1 个失败，1 个正常，`1 - 1 + 1 + 0 = 1`，成功池坍缩为`1`并与`1`运算，最后得到结果`2`

### 宽容求值

在遇到某些不合法的情况时，本引擎不会报错：

- 如果遇到 xdy、xdF 或 xdC 这种情况中，x 小于等于 0 或 y 小于等于 0 时，不会报错，而是返回一个空的骰池，数值运算时视为 0
- 在一些期望整数的地方，得到的却是浮点数时，本引擎会直接截断，行为与 rust 中，将`f64`截断为`i32`时的行为一致，实际上代码中对所有此类情形都会直接截断处理，超过`i32`表达范围的数会被截断为`i32`所能表示的最大值/最小值，但是我不认为在这种应用场景下，用户会使用超过`i32`表达范围的数

但是在下述情况，引擎会直接抛出异常：

- 任何形式的除以 0 错误
- `max`或`min`函数面对空的列表，却被要求返回一个数时

### 投掷顺序与轮数

遇到嵌套情况时，投掷顺序是一个很重要的问题，以`1d4 + (1d6)d8!`为例，引擎会贪婪地从根部遍历计算图（实际上是树），将所有它见到的已经准备好投掷的骰子加入待投掷列表，因此对于上述表达式，投掷顺序如下：

- 第一轮投掷：`1d4`和`1d6`
- 第二轮投掷：`1d6`个`d8`
- 第三轮投掷：如果上一轮投掷中投出了`n`个`8`，则会投掷`nd8`
- 第四轮投掷：如果上一轮投掷中投出了`m`个`8`，则会投掷`md8`
- ......

### 递归限制和骰子数限制

在开发者调用 API 时，会遇到`recursion_limit`和`dice_count_limit`这两个参数，这两个参数无法缺省，是为了限制某些表达式无限制地消耗资源而设计的。达到限制时如果投掷依然没有结束，会直接抛出异常。

- `recursion_limit`限制投掷的最多轮数，即使用户写出`1d6r<8`这种会永远重新投掷的表达式，投掷也会在`recursion_limit`轮后中止并抛出异常；
- `dice_count_limit`则限制整个过程中，能被投掷的骰子总数。

### 具体语法与优先级

解析器使用递归下降法实现，具体语法如下：`[]` 表示可选，`{}` 表示重复零或多次

> 注意，这里的`**`仅用于列表重复，不是幂运算符

```
expr            = term { ("+" | "-") term } ;
term            = unary { ("*" | "/" | "//" | "%" | "**") unary } ;
unary           = ("+" | "-") unary | dice_with_modifiers ;
dice_with_modifiers
                = dice_expr { modifier } ;

// 骰子表达式（计数可省略，省略时默认为 1）
dice_expr       = atom | [atom] ("d" atom | "dc" | "df") ;

// 原子表达式
atom            = number
                | list
                | function_call
                | "(" expr ")"
                | "{" expr "}" ;

list            = "[" [expr { "," expr }] "]" ;

function_call   = func_name "(" [expr { "," expr }] ")"
                | "filter" mod_param "(" [expr { "," expr }] ")" ;

func_name       = "floor" | "ceil" | "round" | "abs"
                | "max" | "min" | "sum" | "avg"
                | "len" | "rpdice" | "sortd" | "sort" | "tolist" ;

// 修饰符（后缀）
modifier        = type1_modifier
                | type2_modifier
                | type3_modifier ;

type1_modifier  = ("kh" | "kl" | "dh" | "dl") [atom]
                | ("min" | "max") atom ;

type2_modifier  = ("r" | "!" | "!!") [mod_param] [limit] ;

type3_modifier  = ("cs" | "df" | "sf") mod_param ;

mod_param       = [compare_op] atom ;
compare_op      = "<" | "<=" | ">" | ">=" | "=" | "<>" ;

limit           = ("lt" atom ["lc" atom])
                | ("lc" atom ["lt" atom]) ;
```

从上述语法可以看出，表达式的优先级从高到低依次为：

- 原子表达式（数字、列表、函数调用、括号表达式）
- 骰子表达式
- 骰子修饰符
- 一元运算符`+`和`-`
- 乘法、除法、整除、取模和列表重复运算符
- 加法和减法运算符

### 使用指南

在下面的描述中`x`、`y`表示返回可以返回数字的表达式（包括骰子池和成功池），`lst`表示返回列表的表达式，`dp`表示返回骰子池的表达式，`sp`表示返回成功池的表达式。

在下述描述中，被方括号`[]`包裹的参数是可选的，被花括号`{}`包裹的参数是必须的。

`mod_param`表示比较表达式形如`=3`，`>8`，`<=(1d6)`等等一个比较符跟上一个可以返回数字的表达式，在大多数情况下`=`号可以缺省，`2d8r=1`和`2d8r1`的效果是一样的。目前支持的比较符有：

- `=`：等于
- `<>`：不等于
- `<=`：小于等于
- `<`：小于
- `>=`：大于等于
- `>`：大于

`limit`表示限制条件，可以用来限制重新投掷和爆骰的次数和/或总数，形如`lt{x}lc{y}`，表示限制重新投掷或爆骰的总轮数（迭代次数）不超过`x`，且限制重新投掷或爆骰的总个数不超过`y`。两者可以单独使用，也可以一起使用，顺序不限。如，`lt3`表示限制重新投掷或爆骰的总轮数不超过 3 轮，`lc5`表示限制重新投掷或爆骰的总个数不超过 5 个，`lt2lc4`或`lc4lt2`表示同时限制重新投掷或爆骰的总轮数不超过 2 轮且总个数不超过 4 个。

#### 基本元素

- 普通数字：任何一个普通数字都是最简单的可以返回数字的表达式，如`1`，`2.5`
- 显式列表：被方括号所包裹的一串用逗号分隔的可以返回数字的表达式，如`[]`，`[1]`，`[1d6, 1d8]`

#### 基本骰池

- `[x]d{y}`：投掷`y`个`x`面骰，返回骰子池，`x`缺省时视为 1，如`8d6`、`d20`、`(1d4 + 2)d10`
- `[x]dF`：投掷`x`个命运骰（返回 0、1 或-1），返回骰子池，`x`缺省时视为 1，如`4dF`、`(1d6)dF`
- `[x]dC`：投掷`x`个硬币（返回 0 或 1），返回骰子池，`x`缺省时视为 1，如`3dC`、`(2d4)dC`

#### 修饰符

- `{dp}kh[x]`：从骰子池中保留最大的`x`个骰子，返回骰子池，`x`缺省时视为 1，如`4d6kh3`、`2d20kh`
- `{dp}kl[x]`：从骰子池中保留最小的`x`个骰子，返回骰子池，`x`缺省时视为 1，如`4d6kl2`、`2d20kl`
- `{dp}dh[x]`：从骰子池中移除最大的`x`个骰子，返回骰子池，`x`缺省时视为 1，如`4d6dh2`、`2d20dh`
- `{dp}dl[x]`：从骰子池中移除最小的`x`个骰子，返回骰子池，`x`缺省时视为 1，如`4d6dl1`、`2d20dl`
- `{dp}min{x}`：将骰子池中所有小于`x`的值变为`x`，返回骰子池，如`4d6min3`、`2d20min(1d4 + 2)`
- `{dp}max{x}`：将骰子池中所有大于`x`的值变为`x`，返回骰子池，如`4d6max4`、`2d20max15`
- `{dp}r{mod_param}[limit]`：对骰子池中所有满足`mod_param`条件的骰子重新投掷，如果新投出的值中依然有满足条件的，递归式地重新投掷，返回骰子池，`limit`为限制条件，缺省表示不限制，如`4d6r<3`、`(2d10)d20r=1lt2lc5`。注意，本解析器没有`ro`修饰符，可以通过添加`lt1`的限制条件来达到类似效果
- `{dp}![mod_param][limit]`：骰子池中每有一个满足`mod_param`条件的骰子，就再投掷一个新的骰子，如果新投出的值中依然有满足条件的，递归式地再次投掷，返回骰子池，`limit`为限制条件，缺省表示不限制。如果没有提供`mod_param`，则默认为条件为投出了骰子的最大值如`1d6!>5`、`2d10!lt3`
- `{dp}!![mod_param][limit]`：与上一条类似，但是新投出的骰子会被加入到引起其投掷到那个骰子池中元素的值上，而不是单独作为一个新的骰子加入骰子池。
- `{dp}sf{mod_param}`：将骰子池中，所有满足`mod_param`条件的骰子移除，返回骰子池，如`4d6sf<3`
- `{dp|sp}df{mod_param}`：将骰子池或成功池中，所有满足`mod_param`条件的骰子标记为失败，返回成功池，如`4d6df>5`、`4d20cs>=15df=1`
- `{dp|sp}cs{mod_param}`：将骰子池或成功池中，所有满足`mod_param`条件的骰子标记为成功，返回成功池，如`4d20cs>=15`

#### 函数

- `floor`：若参数为数，则返回向下取整后的数值；若参数为列表，则对列表中每一个元素进行向下取整操作，返回列表。对于超过 1 个参数的情况，尝试将所有参数解释为一个列表。如`floor(3.7)`、`floor([1.2, 2.5, 3.8])`、`floor(1.5, 2.8, 3.3)`
- `ceil`：同上，但是向上取整
- `round`：同上，但是四舍五入取整
- `abs`：同上，但是取绝对值
- `max`：若只有一个参数，且为列表，则返回列表中的最大值；若有 2 个参数，第一个为列表，第二个为数（记为 n），则返回列表中最大的 n 个值，保证原顺序。其他情况则尝试将所有参数解释为一个列表，返回最大值。如`max([1, 5, 3, 9, 2])`、`max([1d6, 2d6, 3d6], 2)`、`max(1, 5, 3, 9, 2)`
- `min`：同上，但是返回最小值或最小的 n 个值
- `sum`：参数为列表时，返回列表中所有元素的和，其他情况尝试将所有参数解释为一个列表，返回和。如`sum([1, 2, 3, 4])`、`sum(1, 2, 3, 4)`，对于空列表，返回 0
- `avg`：同上，但是返回平均值，若列表为空则返回 0
- `len`：参数为列表时，返回列表中元素的个数，其他情况尝试将所有参数解释为一个列表，返回元素个数。如`len([1, 2, 3, 4])`、`len(1, 2, 3, 4)`
- `sort`：参数为列表时，返回列表中元素按从小到大排序后的新列表，其他情况尝试将所有参数解释为一个列表，返回排序后的新列表。如`sort([3, 1, 4, 2])`、`sort(3, 1, 4, 2)`
- `sortd`：同上，但是按从大到小排序
- `tolist`：仅接受一个骰子池或成功池参数，返回对应的列表。如`tolist(4d6dl1)`、`tolist(4d20cs>=15df=1)`
- `filter{mod_param}`：参数为列表时，返回一个新列表，新列表中仅包含`lst`中满足`mod_param`条件的元素，其他情况尝试将所有参数解释为一个列表。如`filter>=3([1,2,3,4,5])`、`filter<=(1d6)(1,2,3,4,5,6)`

#### 二元运算符

- 加法`+`：对于两个数，返回他们的和。对于两个列表，返回将两个列表拼接后的新列表。对于一个数和一个列表，进行广播计算
- 减法`-`：对于两个数，返回他们的差。对于一个数和一个列表，进行广播计算
- 乘法`*`：对于两个数，返回他们的积。对于一个数和一个列表，进行广播计算
- 除法`/`：对于两个数，返回他们的商。对于一个数和一个列表，进行广播计算
- 整除`//`：对于两个数，返回他们的整数商。对于一个数和一个列表，进行广播计算，实际计算时，先进行除法运算再向下取整
- 取模`%`：对于两个数，返回他们的模。对于一个数和一个列表，进行广播计算

#### 特殊

下面是特殊操作，在从抽象语法树转化为高阶中间表示时就会消失，可以理解为一种特殊的语法糖

- 列表重复`lst ** x`：将列表重复`x`次，返回新列表，如`[1,2] ** 3`返回`[1,2,1,2,1,2]`，但是`lst`必须是显式列表或可被折叠为显式列表的表达式，`x`必须是一个常数或可被折叠为常数的表达式，且为正数。换言之，`lst`和`x`必须在运行前就能确定其值。设计之初的目的是为了支持`[4d6kh3] ** 6`，如此简洁就可以表示投掷 DND 5e 属性值的经典方法，实在是太酷啦

- 骰子重复`rpdice`：直接受一个参数，将这个参数中所有骰子的个数乘以 2。用来模拟“暴击规则”。如`rpdice(1d8 + 2d6)`会变为`2d8 + 4d6`，`(1d6)d10`会变为`(2d6*2)d10`。注意，`rpdice`并非计算，而是某种直接操纵抽象语法树的操作

## 项目结构

- `types/`：存放使用到的各类 structure
- `optimizer/`：常数折叠和表达式合并相关代码：HIR -> HIR
- `bin/`：其他可执行文件，用于性能测试
- `grammar.rs`：将字符串解析为抽象语法树：String -> Expr
- `lower.rs`：将抽象语法树降级为携带类型信息的高阶中间表示：Expr -> HIR
- `compiler.rs`：将高阶中间表示转化为可以携带运行时信息的计算图：HIR -> EvalGraph
- `runtime_engine.rs`：控制 EvalGraph 计算和与外界交互的相关代码
- `runtime.rs`：将 runtime_engine 包装成 wasm 接口
- `render_result.rs`：将 EvalGraph 的拓扑结构和计算后的值提取出来，变为方便前端渲染的格式
- `lib.rs`
- `main.rs`

## License

This project is licensed under the MIT License.
